# Penjelasan Tugas 4 PBP

## Identitas
Nama    : Jaycent Gunawan Ongris<br>
NPM     : 2106750231<br>
Kelas   : F

## Link Hasil Deploy
Link untuk menuju ke web yang sudah di-deploy dapat diklik di.

## Jawaban dari Pertanyaan
### Kegunaan CSRF Token
CSRF Token yang dimasukkan pada berkas *form* berfungsi untuk mencegah serangan yang berupa CSRF (Cross Site Request Forgery). Serangan ini akan memanfaatkan *state user* yang sudah terautentikasi untuk melakukan aksi yang tidak seharusnya *user* ingin lakukan, seperti mengubah *request* dari *user* pada aplikasi. CSRF Token dalam implementasinya akan di-*generate* pada *server-side* saat halaman di-*render* dan token ini akan dicocokkan dengan *request* yang masuk. Jika hasil pencocokkan tidak sesuai, maka *request* tidak akan dilayani.<br>
Tentu saja kita tetap masih bisa menjalankan aplikasi tanpa CSRF Token ini, yang dapat dilakukan dengan menambahkan potongan kode `@csrf_exempt` di atas definisi fungsi yang bersesuaian di `views.py`. Akan tetapi, hal ini sangat tidak disarankan untuk dilakukan karena dapat meningkatkan potensi terjadinya serangan CSRF oleh oknum yang tidak bertanggung jawab.

### Pembuatan Form secara Manual
Ya, tentu saja *form* dapat dibuat secara manual tanpa memanfaatkan *template* yang di-*generate* dari Django, salah satu contohnya adalah *form* untuk menambahkan *task* pada aplikasi ini. Saya juga membuat *form* tersebut tanpa menggunakan `forms.py`. Cara yang saya lakukan dalam membuat *form* tersebut adalah membuat suatu berkas HTML yang akan diisi dengan *form* tersebut, lalu membuat tag pembuka dan penutup untuk *form*, yaitu `<form>...</form>`, lalu ditambahkan *attribute* yang bersesuaian, dalam hal ini saya menggunakan *method* `POST` yang dijadikan nilai dari *attribute* `method`. Selain itu, dapat ditambahkan juga *attribute* `action` yang dapat berisi *URL Destination* dari *form*. Kemudian, di dalam tag tersebut, dapat ditambahkan elemen-elemen HTML yang dapat digunakan bagi *user* untuk meng-*input* data, seperti `<input>...</input>`, `<textarea>...</textarea>`, dan sebagainya. Lalu, tambahkan atribut-atribut yang diperlukan pada tag tersebut. Salah satu atribut yang penting adalah `name`, karena `value` dari atribut ini akan digunakan untuk mendapatkan data yang dimasukkan *user* pada *field* tersebut. Selanjutnya, kita dapat membuat fungsi pada `views.py` yang akan mengambil data yang sudah dimasukkan oleh *user*. Pengambilan data tersebut dapat dengan menggunakan `request.POST.get('attribute')` atau `request.POST['attribute']`. Setelah itu, data tersebut akan diproses sesuai dengan keinginan kita, entah itu mau dimasukkan ke *database*, mau diautentikasi, atau keperluan lainnya.

### Alur Data pada Form
Pertama-tama user akan memasukkan data pada *form*, spesifiknya pada *field* yang sudah disediakan. Kemudian, untuk mengambil data dari form tersebut, dapat dilakukan pemanggilan `request.POST`. Pemanggilan ini akan mengembalikan *dictionary* dengan *key* berupa nilai dari atribut `name` pada *field* dan *value* berupa data yang diisi oleh *user*. Sampai saat ini, kita sudah mendapatkan data yang dimasukkan *user* pada *form* tersebut. Selanjutnya, kita akan memasukkan data tersebut ke *database* dapat dengan memanfaatkan *method* `create(attr1=val1, attr2=val2, ...)` atau dengan melakukan instansiasi *class* yang menjadi *model*, lalu meng-*edit* atribut dari *class* tersebut satu persatu, dan terakhir menyimpannya dengan menggunakan *method* `save`. Sampai saat ini, data sudah tersimpan ke *database* Django. Untuk ditampilkan ke dalam berkas HTML, kita harus mengakses data tersebut dari *database* terlebih dahulu, dapat dengan menggunakan *method* `all` untuk mengambil semua objek dari *database*, *method* `filter` untuk mengambil objek yang memenuhi kriteria yang di-*state* pada parameter *method* tersebut, atau dapat juga dengan *method* `get` untuk mengambil tepat satu objek yang memenuhi kriteria yang di-*state* pada parameter *method* tersebut (umumnya memanfaatkan *primary key* yang bersifat unik agar bisa mengembalikan tepat satu). Setelah itu, data yang sudah didapatkan lalu dimasukkan ke `context` yang menjadi parameter fungsi `render` dari fungsi yang bersesuaian di `views.py` agar dapat diakses dan ditampilkan menggunakan *template tags* pada berkas HTML yang bersesuaian.

### Tahap-Tahap Implementasi Checklist
Tahapan yang saya lakukan dalam mengimplementasikan checklist:
1. Pertama-tama, saya membuat suatu aplikasi baru yang bernama "todolist" dengan menjalankan perintah `python manage.py startapp todolist` dan menambahkan `todolist` ke `INSTALLED_APPS` di `settings.py`.
2. Selanjutnya, saya menambahkan `routing` berupa `path('todolist/', include('todolist.urls'))` pada `urlpatterns` di `urls.py` milik `project_django`.
3. Setelah itu, saya membuat sebuah class `Task` di `models.py` pada aplikasi *todolist* dengan atribut seperti yang telah diberikan pada soal, yaitu `user`, `date`, `title`, dan `description`. 
4. Lalu, saya menambahkan suatu fungsi `register` untuk meng-*handle* *user* yang ingin *register* pada `views.py` milik `todolist`. Kemudian, saya membuat berkas `register.html` sebagai halaman *register* dari *user*. Selanjutnya, saya mengimpor fungsi ini ke dalam `urls.py` pada `todolist` untuk kemudian saya tambahkan ke `urlpatterns`.
5. Saya kemudian membuat suatu fungsi `show_todolist` untuk menampilkan daftar *todolist* pada `views.py` milik `todolist`. Kemudian, saya membuat berkas `todolist.html` sebagai halaman untuk menampilkan *todolist* dari *user*. Selanjutnya, saya mengimpor fungsi ini ke dalam `urls.py` pada `todolist` untuk kemudian saya tambahkan ke `urlpatterns`.
6. Selanjutnya, saya membuat fungsi `login_user` sebagai `login page` dari `user` pada `views.py` milik `todolist`. Kemudian, saya membuat berkas `login.html` sebagai halaman untuk bagi *user* untuk `login`. Setelah itu, saya mengimpor fungsi ini ke dalam `urls.py` pada `todolist` untuk kemudian saya tambahkan ke `urlpatterns`.
7. Setelah itu, saya membuat fungsi `logout_user` untuk meng-*handle* *user* yang ingin *logout* dari aplikasi. Fungsi ini akan mengembalikan fungsi `redirect` yang akan membawa *user* kembali ke halaman *login*. Setelah itu, saya mengimpor fungsi ini ke `urls.py` pada `todolist` dan memasukkannya ke `urlpatterns`. Saya juga kemudian menambahkan tombol untuk *logout* pada halaman `todolist.html` yang sudah di-*link* dengan URL `logout` yang berisi mekanisme *logout user*.
8. Selanjutnya, saya akan melakukan restriksi akses terhadap halaman `todolist`, yaitu user yang sudah login saja yang boleh masuk, dengan cara mengimpor `login_required` pada `views.py` dan menambahkan kode `@login_required(login_url='/todolist/login/')` di atas fungsi `show_todolist`.
9. Sehabis itu, saya membuat suatu fungsi `create_task` pada `views.py` yang berfungsi untuk meng-*handle* *user* yang ingin membuat *task* baru. Saya lalu mengambil data dari *form* yang sudah diisi oleh *user* dengan memanfaatkan `request.POST` untuk kemudian siap dimasukkan ke database. Kemudian, saya membuat berkas `new_task.html` yang berisi *form* bagi *user* untuk memasukkan detail terkait *task* baru. Terakhir, saya membuat *route* ke *page* ini dengan mengimpor fungsi `create_task` pada `urls.py` pada `todolist` dan memasukkannya ke `urlpatterns`. 
10. [BONUS] Selanjutnya, saya membuat tambahan atribut pada `class Task` yaitu `is_finished` dengan *default value False*. Setelah itu, saya membuat skema migrasi dan melakukan migrasi dengan menjalankan perintah `python manage.py makemigrations` dan `python manage.py migrate`.
11. [BONUS] Lalu, saya membuat fungsi baru yang bernama `delete_task` pada `views.py` yang menerima parameter `request` dan `id`. Fungsi ini berfungsi untuk menghapus *instance* dengan `id` yang di-*pass* ke parameter tersebut. Caranya adalah dengan mengambil objek tersebut dari *database* dengan menggunakan *method* `get` berdasarkan `id` lalu dihapus dengan *method* `delete`. Setelah itu, saya mengimpor fungsi ini ke `urls.py` pada `todolist` dan memasukkannya ke `urlpatterns`. Saya kemudian membuat suatu kolom baru di tabel pada `todolist.html` untuk menghapus objek yang bersangkutan.
12. [BONUS] Setelah itu, saya membuat fungsi yang bernama `change_status` pada `views.py` yang menerima parameter `request` dan `id` untuk mengubah status dari atribut `is_finished` dari `True` ke `False` atau sebaliknya. Sama seperti pada *step* sebelumnya, saya pertama-tama mengambil objek tersebut dari *database* dengan menggunakan *method* `get` berdasarkan `id`, lalu saya mengubah atribut dari objek tersebut. Selanjutnya, saya menyimpan perubahan tersebut dengan memanfaatkan *method* `save`. Setelah itu, saya mengimpor fungsi ini ke `urls.py` pada `todolist` dan memasukkannya ke `urlpatterns`. Kemudian, saya membuat dua kolom baru pada tabel di `todolist.html` untuk menampilkan status dari *task* dan tombol untuk mengubah status tersebut.
13. Untuk melakukan *tracking* perubahan pada *database*, saya membuat akun *superuser* agar dapat mengakses *Django Admin*. Lalu, saya menambahkan model `Task` ke dalam `admin.py`.
14. Selanjutnya, saya melakukan `add`, `commit`, dan `push` ke GitHub, lalu melakukan *re-run jobs* agar perubahan yang telah saya buat ter-*deploy*.

### Username dan Password


### Referensi
https://www.educative.io/answers/what-is-a-csrf-token-in-django<br>
